#!/usr/bin/env node
'use strict';

var fs = require('fs');
var globby = require('globby');
var minify = require('html-minifier').minify;
var mkdirp = require('mkdirp');
var del = require('del');
var mergeOptions = require('merge-options');
var isBinaryFile = require("isbinaryfile");
var path = require('path');
var ProgressBar = require('progress');

var webarchiver = {};
(function(){
    module.exports = webarchiver = {

        /**node
         * The main webarchiver function.
         * @param {object} options - The options object.
         */
        webArchiver: function (options) {
            // Check that there are options.
            if (options == null) throw new Error("No options given.");
            // Check that there is an input pattern.
            if (options.files == null) throw new Error("No input files defined in options.");
            // Check output options make sense.
            if (!options.inPlace && !options.output) throw new Error("You must set either 'output' or 'inplace'.");

            // Create option defaults and merge in the supplied options.
            this.createOptions(options);

            // Grab the files.
            this.inPaths = globby.sync(this.options.files);
            if (this.inPaths === undefined || this.inPaths.length == 0) {
                throw new Error("No input files found.");
            }

            // "Just copy" file list.
            this.justCopy = options.justCopy ? globby.sync(options.justCopy) : [];

            // Number of files.
            this.numFiles = this.inPaths.length;

            // Set up progress bar.
            this.progressBar();

            // Get the common prefix directories of all the files.
            this.startPath = this.getStartPath(this.inPaths);
            this.startPathLength = this.startPath.length;

            // Where to output the files.
            this.outDir = this.getOutDir();

            // Create tracking for altered filenames so they don't get reused.
            if (this.options.slugify) {
                this.slugMap = {};
            }

            // The first variable name to use.
            this.varName = 'a';

            // Tracking data.
            this.files = {};
            this.replacements = {};

            // Process the files.
            this.processFiles();

            // Output the files.
            this.createOutFiles();

            // Write the PHP vfile.
            this.createVarFile();

            // Write the app state.
            if (this.options.writeState) {
                var out = {};
                for (var x in this) {
                    if (this.hasOwnProperty(x) && typeof(x) != 'function') {
                        out[x] = this.x;
                    }
                }
                require('jsonfile').writeFileSync(this.outDir + 'state.json', out);
            }

            // Saved one tick for the end.
            this.bar.tick(1, {'msg': 'Files processed, completing job...'});

        },

        // Create the default options object and merge in the param values.
        createOptions: function (options) {
            var defaults = {
                vFile: 'v.php',
                passes: 2,
                skipContaining: ['<?'],
                minify: {
                    collapseBooleanAttributes: true,
                    collapseInlineTagWhitespace: true,
                    collapseWhitespace: true,
                    conservativeCollapse: false,
                    html5: false,
                    includeAutoGeneratedTags: false,
                    minifyCSS: true,
                    minifyJS: true,
                    removeAttributeQuotes: true,
                    removeComments: true,
                    removeEmptyAttributes: true,
                    removeRedundantAttributes: true,
                    removeScriptTypeAttributes: true,
                    removeStyleLinkTypeAttributes: true
                },
                dedupe: {
                    minLength: 20,
                    minSaving: 10,
                    startsWith: ['<', '{', '\\(', '\\['],
                    endsWith: ['>', '}', '\\)', '\\]', '\\n', '\\s']
                }
            };
            this.options = mergeOptions(defaults, options);
        },

        progressBar: function () {
            if (!this.options.noProgress) {
                var additional = this.numFiles + 1;
                if (this.options.slugify) {
                    additional += this.numFiles;
                }
                this.bar = new ProgressBar('  Archiving [:bar] :percent :msg ETA: :eta sec', {
                    width: 50,
                    // This is a 1+2+3+4... formula multiplied by passes plus numFiles to write out the files plus one
                    // extra tick for writing the vfile.
                    total: ((this.numFiles * (this.numFiles + 1)) / 2) * this.options.passes + additional
                });
            }
            else {
                // Dummy.
                this.bar = {
                    tick: function () {
                    }
                };
            }
        },

        // Create tracking object for a file.
        createFileTrack: function (fileKey) {
            this.files[fileKey] = {
                path: this.inPaths[fileKey].substr(this.startPathLength),
                skip: this.justCopy.indexOf(this.inPaths[fileKey]) > -1,
                textFile: true
            };
            // Output path.
            this.files[fileKey].outPath = this.outDir + this.files[fileKey].path;
        },

        // Check and handle directories and binary files.
        handleDirsAndBinaries: function (fileKey) {
            if (!this.files[fileKey].skip) {
                if (fs.lstatSync(this.inPaths[fileKey]).isDirectory()) {
                    // Directory.

                    // So it isn't used as an 'other' file in dedupes and fs.lstatSync isn't run on the 2nd pass.
                    this.files[fileKey].skip = true;
                    this.files[fileKey].textFile = false;
                }
                else if (isBinaryFile.sync(this.inPaths[fileKey])) {
                    // Process binary files.
                    if (this.inPaths[fileKey] != this.files[fileKey].outPath) {
                        // Ensure the output dir exists.
                        mkdirp.sync(path.dirname(this.files[fileKey].outPath));

                        // Copy the file over.
                        var file = fs.readFileSync(this.inPaths[fileKey], 'binary');
                        fs.writeFileSync(this.files[fileKey].outPath, file, 'binary');
                    }
                    // So it isn't used as an 'other' file in dedupes and isBinaryFile isn't run on the 2nd pass.
                    this.files[fileKey].skip = true;
                    this.files[fileKey].textFile = false;
                }
            }
        },

        // Determine additional skip conditions based on the contents of the file.
        determineTextFileSkip: function (fileKey, str) {
            if (!this.files[fileKey].skip) {
                for (var j = 0; j < this.options.skipContaining.length; ++j) {
                    if (str.indexOf(this.options.skipContaining[j]) > -1) {
                        this.files[fileKey].skip = true;
                        break;
                    }
                }
            }
        },

        // File processing function.
        processFiles: function () {

            // Alter the filename.
            if (this.options.slugify) {
                // @todo: When adding a feature for pre-analysis of files, include it in this loop.
                for (var fileKey = 0; fileKey < this.numFiles; ++fileKey) {
                    this.createFileTrack(fileKey);
                    this.handleDirsAndBinaries(fileKey);
                    if (!this.files[fileKey].skip) {
                        var str = fs.readFileSync(this.inPaths[fileKey], 'utf8');
                        // Work out slugs.
                        this.slugify(fileKey, str);
                        if (this.options.inPlace) {
                            // Rename.
                            fs.renameSync(this.files[fileKey].path, this.files[fileKey].outPath);
                        }
                    }

                    this.bar.tick(1, {'msg': 'File ' + (fileKey + 1) + '/' + this.numFiles + ' (analyzing)'});
                }
            }

            for (var pass = 0; pass < this.options.passes; ++pass) {
                for (var fileKey = 0; fileKey < this.numFiles; ++fileKey) {
                    if (pass == 0 && !this.options.slugify) {
                        this.createFileTrack(fileKey);
                        this.handleDirsAndBinaries(fileKey);
                    }

                    if (this.files[fileKey].textFile) {
                        // Process text files.
                        var str;
                        if (pass == 0) {
                            // Read the file contents.
                            str = fs.readFileSync(this.inPaths[fileKey], 'utf8');
                            // Determine additional skip conditions based on the contents of the file.
                            this.determineTextFileSkip(fileKey, str);
                        }

                        // Ensure it's not a file to skip.
                        if (!this.files[fileKey].skip) {
                            if (pass == 0) {
                                // One-time string manipulations.
                                str = this.manipulations(fileKey, str);
                            }

                            if (this.options.dedupe !== false) {
                                if (pass == 0) {
                                    // Fragment the file for use in deduplication.
                                    this.files[fileKey].frags = this.createFragments(this.addSlashes(str), this.options.dedupe);
                                }

                                // Apply existing replacements.
                                for (var varName in this.replacements) {
                                    if (this.replacements.hasOwnProperty(varName)) {
                                        // No need to call replacementAllowed here because if it wasn't allowed it wasn't stored.
                                        this.files[fileKey].frags = this.doReplace(this.files[fileKey].frags, this.replacements[varName], varName, fileKey);
                                    }
                                }

                                // Deduplicate within this file and with previous files.
                                var matches = this.findDuplicates(fileKey);
                                if (matches.length > 0) {
                                    // Apply the deduplication replacements.
                                    this.processMatches(matches);
                                }

                            }
                        }

                        // Write the current text file if it wasn't deduped.  It may get deduped later and will be overwritten.
                        if (pass == 0 && (!this.options.dedupe || !this.files[fileKey].deduped)) {
                            mkdirp.sync(path.dirname(this.files[fileKey].outPath));
                            fs.writeFileSync(this.files[fileKey].outPath, str);
                        }
                    }

                    this.bar.tick(fileKey + 1, {'msg': 'File ' + (fileKey + 1) + '/' + this.numFiles + ' (pass ' + (pass + 1) + '/' + this.options.passes + ')'});
                }

            }

        },

        // Write the deduplicated files.
        createOutFiles: function () {
            if (this.options.dedupe !== false) {
                for (var fileKey = 0; fileKey < this.numFiles; ++fileKey) {
                    if (this.files[fileKey].deduped) {
                        mkdirp.sync(path.dirname(this.files[fileKey].outPath));
                        fs.writeFileSync(
                            this.files[fileKey].outPath,
                            this.fixCodes(
                                this.prepend(this.options.vFile, (this.files[fileKey].path.match(/\//g) || []).length)
                                + this.files[fileKey].frags.join('')
                                + this.append()
                            )
                        );
                    }
                    this.bar.tick(1, {'msg': 'Write ' + (fileKey + 1) + '/' + this.numFiles});
                }
            }
            else {
                this.bar.tick(this.numFiles, {'msg': 'Write ' + this.numFiles + '/' + this.numFiles});
            }
        },

        // Write the PHP variables file.
        createVarFile: function () {
            var vFile = '<?php ';
            for (var varName in this.replacements) {
                if (this.replacements.hasOwnProperty(varName)) {
                    vFile += this.varCode(varName) + '=\'' + this.replacements[varName] + '\';';
                }
            }
            fs.writeFileSync(this.outDir + this.options.vFile, this.fixCodes(vFile));
        },

        // Act on new matches.
        processMatches: function (matches) {
            for (var match = 0; match < matches.length; ++match) {
                // Use a function as a last chance to reject this match.
                if (this.replacementAllowed(matches[match])) {
                    // Store the replacement.
                    this.replacements[this.varName] = matches[match].str;

                    // Make the replacements.
                    for (var fileKey in matches[match].occ) {
                        if (matches[match].occ.hasOwnProperty(fileKey)) {
                            this.files[fileKey].frags =
                                this.doReplace(this.files[fileKey].frags, matches[match].str, this.varName, fileKey);
                        }
                    }

                    // varName has been spent, so update to another one.
                    this.varName = this.nextVarName(this.varName);
                }
            }
        },

        /**
         * Determines whether to allow the current duplicate to be replaced in files.
         *
         * The implementation of this function should remain ignorant of which string/file the replacement is being applied
         * to as its result is reused for other files without calling this function again.
         *
         * @param match Object containing information about the deduplication match.
         * @returns {boolean}
         */
        replacementAllowed: function (match) {
            var occSatisfied = true;
            if (this.options.dedupe.minOcc) {
                var occurrences = 0;
                for (var i in match.occ) {
                    if (match.occ.hasOwnProperty(i)) {
                        occurrences += match.occ[i].length;
                    }
                }
                occSatisfied = occurrences >= this.options.dedupe.minOcc;
            }
            return occSatisfied && match.str.length >= this.autoMinLength();
        },

        // Generates an automatic value for minLength based on minSaving and the length of the current shortCode.
        autoMinLength: function () {
            return this.options.dedupe.minSaving + this.shortCode(this.varName).length;
        },

        // Perform the replacement.
        doReplace: function (frags, match, varName, fileKey) {
            var seek, offset;
            for (var frag = 0; frag < frags.length; ++frag) {
                if (match.indexOf(frags[frag]) === 0) {
                    // This could be it.
                    seek = frag + 1;
                    offset = frags[frag].length;
                    while (seek < frags.length && offset < match.length && match.substring(offset, offset + frags[seek].length) === frags[seek]) {
                        offset += frags[seek].length;
                        seek++;
                    }
                    if (offset >= match.length) {
                        // This is it.  Make the replacement and clear out the extra elements.
                        frags[frag] = this.shortCode(varName);
                        for (var i = frag + 1; i < seek; ++i) {
                            frags[i] = '';
                        }
                        // Mark this file as deduped.
                        this.files[fileKey].deduped = true;

                        // Wind f forward.
                        frag = seek - 1;
                    }
                }
            }
            // Remove the cleared elements as they will hinder stacked matches.
            return frags.filter(Boolean);
        },

        // Clean up a string with replacements in it.
        fixCodes: function (str) {
            str = this.replaceAll(str, ".''", '');
            str = this.replaceAll(str, "''.", '');
            return str;
        },

        // Replace all occurrences of a substring.
        replaceAll: function (str, find, replace) {
            return str.replace(new RegExp(this.escapeRegExp(find), 'g'), replace);
        },

        // For use with replaceAll().
        escapeRegExp: function (str) {
            return str.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
        },

        // Build the replacement string.
        shortCode: function (varName) {
            return "'." + this.varCode(varName) + ".'";
        },

        // Creates a variable string from a variable name.
        varCode: function (varName) {
            return '$' + varName;
        },

        // Build the prepend string to place at the start of each deduplicated file.
        prepend: function (vFile, up) {
            for (var i = 0; i < up; ++i) {
                vFile = '../' + vFile;
            }
            return '<?php include \'' + vFile + '\';echo \'';
        },

        // Adds slashes to the contents of a file to make it compatible with deduplication.
        addSlashes: function (str) {
            return (str + '').replace(/'/g, "\'").replace(/\\/g, '\\');
        },

        // Build the append string to place at the end of each deduplicated file.
        append: function () {
            return "';";
        },

        // Get common start of an array of paths.
        getStartPath: function (strings) {
            // Sorts the strings and compares common starting substring of first and last string.
            var paths = strings.concat().sort(), j = 0, pathShort = paths[j], pathLong = paths[paths.length - 1], i = 0;
            // Skip one-level dirs at beginning of array.
            while (pathShort.indexOf('.') == -1 && pathShort.indexOf('/') == -1) pathShort = paths[++j];
            var pathShortLength = pathShort.length;
            while (i < pathShortLength && pathShort.charAt(i) === pathLong.charAt(i)) i++;
            var sharedStart = pathShort.substring(0, i);
            // Omit chars after the final forward-slash.
            if (sharedStart.indexOf("/") > -1) sharedStart = sharedStart.substr(0, 1 + sharedStart.lastIndexOf("/"));
            return sharedStart;
        },

        // Get the output directory path.
        getOutDir: function () {
            var out = this.options.inPlace ? this.startPath : this.options.output.replace(/\/?$/, '/') + (this.options.fullNest ? this.startPath : "");
            // Return with trailing slash.
            return out.replace(/\/?$/, '/');
        },

        // Fragment a file to prepare it for deduplication.
        createFragments: function (str) {
            var re = new RegExp("(["
                + this.options.dedupe.startsWith.join('')
                + "]?[^" + this.options.dedupe.startsWith.join('')
                + "" + this.options.dedupe.endsWith.join('') + "]*["
                + this.options.dedupe.endsWith.join('')
                + "]?){1}", "g");

            return str.split(re).filter(Boolean);
        },

        // Find duplicates function.
        findDuplicates: function (fileKey) {
            var matches = [];
            var a = this.files[fileKey].frags;
            var minLen = this.options.dedupe.minLength ? this.options.dedupe.minLength : this.autoMinLength();
            for (var fileKey2 = fileKey; fileKey2 >= 0; --fileKey2) {
                if (!this.files[fileKey2].skip) {
                    var b = this.files[fileKey2].frags;
                    this.fragmentMatches(matches, a, b, fileKey, fileKey2, minLen);
                }
            }
            return matches;
        },

        /**
         * Searches for common consecutive items in two arrays of strings.
         *
         * If a_name and b_name are the same it will be aware that it is matching within the same piece of data.
         *
         * @param {object} matches the object in which to add results, passed in so it can be reused.
         * @param {array} a an array of strings.
         * @param {array} b an array of strings.
         * @param {int|string} a_name name of array a, usually an integer.
         * @param {int|string} b_name name of array b, usually an integer.
         * @param {int} min the minimum size of a string to be considered.
         */
        fragmentMatches: function (matches, a, b, a_name, b_name, min) {
            var a_length = a.length;
            for (var i = 0; i < a_length; ++i) {
                var b_length = b.length;
                for (var j = 0; j < b_length; ++j) {
                    if ((a_name != b_name || i != j) && a[i] === b[j]) {
                        var str = a[i];
                        var k = 1;
                        while (i + k < a_length && j + k < b_length && a[i + k] === b[j + k]) {
                            str += a[i + k];
                            ++k;
                        }
                        if (str.length >= min) {
                            var existing = this.findWithAttr(matches, 'str', str);
                            if (existing > -1) {
                                if (matches[existing].occ[a_name]) {
                                    if (matches[existing].occ[a_name].indexOf(i) == -1) {
                                        matches[existing].occ[a_name].push(i);
                                    }
                                }
                                else {
                                    matches[existing].occ[a_name] = [i];
                                }
                                if (matches[existing].occ[b_name]) {
                                    if (matches[existing].occ[b_name].indexOf(i) == -1) {
                                        matches[existing].occ[b_name].push(i);
                                    }
                                }
                                else {
                                    matches[existing].occ[b_name] = [i];
                                }
                            }
                            else if (a_name != b_name) {
                                matches.push({
                                    'str': str,
                                    'occ': {[a_name]: [i], [b_name]: [j]}
                                });
                            }
                            else {
                                matches.push({
                                    'str': str,
                                    'occ': {[a_name]: [i, j]}
                                });

                            }
                            // Wind i and j forward so we don't just match the suffix of the previous match.
                            i += k - 1;
                            j += k - 1;
                        }
                    }
                }
            }
        },

        // Increments a PHP compatible variable name.  Input should start with an alpha char.
        nextVarName: function (str) {
            // Position of char to change.
            var change = str.length - 1;
            // The value of that char.
            var change_char = str[change];
            // Number of zeros to append when flipping.
            var zeros = 0;
            // Iterate backwards while there's a z (flipping).
            while (change_char == 'z') {
                // Increase the length of appended zeros
                zeros++;
                // Move the char to change back.
                change_char = str[--change];
            }
            if (change_char == undefined) {
                // Full flip - string increases in length.
                str = 'a' + Array(str.length + 1).join("0");
            }
            else {
                // Normal increment with partial flip and 9->a handling.
                str = str.substr(0, change)
                    + (change_char == '9' ? 'a' : String.fromCharCode(str.charCodeAt(change) + 1))
                    + Array(zeros + 1).join('0');
            }
            return str;
        },

        // Find the index in an array of objects by the value of an object's property.
        findWithAttr: function (array, attr, value) {
            for (var i = 0; i < array.length; i += 1) {
                if (array[i][attr] === value) {
                    return i;
                }
            }
            return -1;
        },

        // Minify function.
        minify: function (str) {
            return minify(str, this.options.minify);
        },

        // Crude form element disabler.
        disable: function (str) {
            var find = [];
            var replace = [];
            for (var d = 0; d < this.options.disable.length; ++d) {
                find.push('<' + this.options.disable[d]);
                replace.push('<' + this.options.disable[d] + ' disabled');
            }
            return str.replace(new RegExp(find.join('|'), 'g'), function(tagOpen) {
                return replace[find.indexOf(tagOpen)];
            });
        },

        // Get the slugified title.
        slugifySlug: function (str) {
            var title = str.match(/<title[^>]*>([^<]+)<\/title>/)[1];
            if (title != '') {
                if (this.options.slugifyIgnore) {
                    title = title.replace(new RegExp(this.options.slugifyIgnore.join('|'), 'ig'), '');
                }
                if (title != '') {
                    return title.toLowerCase().trim().replace(/ /g, '-').replace(/[^\w-]+/g, '');
                }
            }
            return false;
        },

        // Alter the filename.
        slugify: function (fileKey, str) {
            this.files[fileKey].originalPath = this.files[fileKey].path;
            var fileExt = this.files[fileKey].path.substr(this.files[fileKey].path.lastIndexOf('.'));
            var basePath = this.files[fileKey].path.substr(0, this.files[fileKey].path.lastIndexOf('/') + 1);
            var slug = this.slugifySlug(str);
            if (slug !== false) {
                var disambiguate = 2;
                var changed_slug = slug + fileExt;
                while (changed_slug in this.slugMap) {
                    changed_slug = slug + '-' + disambiguate + fileExt;
                    disambiguate++;
                }
                slug = changed_slug;
                this.files[fileKey].alteredPath = basePath + slug;
                this.files[fileKey].outPath = this.outDir + this.files[fileKey].alteredPath;
                this.slugMap[basePath + slug] = this.files[fileKey].path;
            }
        },

        slugifyReplace: function(str) {
            for (var slug in this.slugMap) {
                str = this.replaceAll(str, this.slugMap[slug], slug);
            }
            return str;
        },

        // Custom string manipulation.
        manipulations: function(fileKey, str) {
            // Minify the file contents.
            if (this.options.minify) {
                str = this.minify(str);
            }

            // Search and replace.
            if (this.options.searchReplace) {
                var a = this.options.searchReplace.search;
                var b = this.options.searchReplace.replace;
                var i = this.options.searchReplace.i ? 'i' : '';
                str = str.replace(new RegExp(a.map(function(x) {
                    return x.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                }).join('|'), 'g' + i), function(c) {
                    return b[a.indexOf(c)];
                });
            }

            // Disable form elements.
            if (this.options.disable) {
                str = this.disable(str);
            }

            // Alter references to altered filenames.
            if (this.options.slugify) {
                str = this.slugifyReplace(str);
            }

            return str;
        }

    };

    // This is for command line usage.
    /* istanbul ignore next */
    if (!module.parent) {
        // Grab command line args.
        var commandLineArgs = require('command-line-args');
        var optionDefinitions = [
            { name: 'files', type: String, multiple: true },
            { name: 'justCopy', type: String, multiple: true },
            { name: 'inPlace', type: Boolean },
            { name: 'output', type: String },
            { name: 'dedupe', type: Boolean },
            { name: 'dedupe.minLength', type: Number  },
            { name: 'dedupe.minSaving', type: Number  },
            { name: 'dedupe.startsWith', type: String, multiple: true },
            { name: 'dedupe.endsWith', type: String, multiple: true },
            { name: 'minify', type: Boolean },
            { name: 'vFile', type: String },
            { name: 'fullNest', type: Boolean },
            { name: 'skipContaining', type: String, multiple: true },
            { name: 'noProgress', type: Boolean },
            { name: 'passes', type: Number }
        ];
        var options = commandLineArgs(optionDefinitions, { partial: true });

        // minify.* options will be in '_unknown', so move them out of there.
        if (options['_unknown']) {
            for (var u = 0; u < options['_unknown'].length - 1; u += 2) {
                options[(options['_unknown'][u]).replace('--', '')] = options['_unknown'][u + 1];
            }
            delete options['_unknown'];
        }

        // Nest dedupe.* and minify.* options correctly.
        for (var o in options) {
            if (options.hasOwnProperty(o)) {
                if (o.indexOf("dedupe.") === 0) {
                    var key = o.substring(7);
                    if (options.dedupe === undefined) options.dedupe = {};
                    options.dedupe[key] = options[o];
                    delete options[o];
                }
                else if (o.indexOf("minify.") === 0) {
                    var key = o.substring(7);
                    if (options.minify === undefined) options.minify = {};
                    if (options[o] == 'true') options[o] = true;
                    if (options[o] == 'false') options[o] = false;
                    options.minify[key] = options[o];
                    delete options[o];
                }
            }
        }

        // Execute the app.
        webarchiver.webArchiver(options);
    }
})();
